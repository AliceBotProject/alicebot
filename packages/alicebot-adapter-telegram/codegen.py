"""用于生成 Telegram 模型和 API 代码的代码生成器。

使用代码生成器来生成 Telegram 模型的想法来自于 https://github.com/nonebot/adapter-telegram。
所使用的 Telegram API 标准来自 https://github.com/PaulSonOfLars/telegram-bot-api-spec。
"""

import subprocess
from keyword import kwlist
from pathlib import Path
from typing import Optional, Union

import aiohttp
import anyio
from pydantic import BaseModel, Field

URL = "https://raw.githubusercontent.com/PaulSonOfLars/telegram-bot-api-spec/main/api.json"

BASE_PATH = Path("packages/alicebot-adapter-telegram/alicebot/adapter/telegram")
MODEL_FILE = BASE_PATH / "model.py"
API_FILE = BASE_PATH / "api.py"
MEDIA_FILE = BASE_PATH / "media.py"


TG_TO_PY_TYPE = {
    "Integer": "int",
    "Float": "float",
    "Boolean": "bool",
    "String": "str",
}

MODEL_CODE_PREFIX = """\"\"\"Telegram 模型。\"\"\"
# autogenerated by codegen.py, do not edit manually.
# ruff: noqa: D101, D102, A002
# pylint: disable=missing-class-docstring

from typing import Generic, Optional, TypeVar, Union

from pydantic import BaseModel, Field

_T = TypeVar("_T")


class Response(BaseModel, Generic[_T]):
    ok: bool
    description: Optional[str] = None
    result: Optional[_T] = None
    error_code: Optional[int] = None


"""
API_CODE_PREFIX = """\"\"\"Telegram API 定义。\"\"\"
# autogenerated by codegen.py, do not edit manually.
# ruff: noqa: D101, D102, A002
# mypy: ignore-errors
# pylint: disable=redefined-builtin, unused-argument, missing-class-docstring, too-many-locals

from typing import Optional, Union

from .model import {}


"""
MEDIA_CODE_PREFIX = """\"\"\"Telegram Media 模型。\"\"\"
# autogenerated by codegen.py, do not edit manually.
# ruff: noqa: D101, D102, A002
# pylint: disable=missing-class-docstring

from typing import Optional, Union

from pydantic import BaseModel

from .message import TelegramMessage
from .model import {}


class TelegramMedia(BaseModel):
    pass


"""

CREATED_MODELS: set[str] = set()
USED_MODELS: set[str] = set()


class FieldDescription(BaseModel):
    """Telegram API 字段描述。"""

    name: str
    types: list[str]
    required: bool
    description: str

    def to_python(self, with_pydantic: bool = False) -> str:
        """生成 Python 字段。"""
        annotation = to_annotation(self.types)
        if self.name in kwlist:
            if not with_pydantic:
                raise ValueError(f"{self.name} is a keyword")
            if self.required:
                return f'{self.name}_: {annotation} = Field(alias="{self.name}")'
            return f'{self.name}_: Optional[{annotation}] = Field(default=None, alias="{self.name}")'
        if self.required:
            return f"{self.name}: {annotation}"
        return f"{self.name}: Optional[{annotation}] = None"


class MethodDescription(BaseModel):
    """Telegram API 方法描述。"""

    name: str
    href: str
    description: Optional[list[str]] = None
    returns: list[str] = Field(default_factory=list)
    fields: list[FieldDescription] = Field(default_factory=list)

    def to_api_method(self) -> str:
        """生成 API 方法字符串。"""
        args = (
            *(field.to_python() for field in self.fields if field.required),
            *(field.to_python() for field in self.fields if not field.required),
        )
        return (
            f"async def {lower_camel_to_snake_case(self.name)}(\n"
            + indent(
                ",\n".join(
                    (
                        "self,\n*" if args else "self",
                        *args,
                    )
                )
            )
            + f",\n) -> {to_annotation(self.returns)}: ..."
        )

    def to_media_model(self) -> Optional[str]:
        """生成 TelegramMedia 模型代码。"""
        if not self.name.startswith("send") or self.name == "sendMessage":
            return None
        exclude_fields = {
            "business_connection_id",
            "chat_id",
            "message_thread_id",
            "disable_notification",
            "protect_content",
            "message_effect_id",
            "reply_parameters",
            "reply_markup",
        }
        fields = [
            (
                field.to_python(with_pydantic=True)
                if f"{field.name}_entities" not in [field.name for field in self.fields]
                else f"{field.name}: Union[None, str, TelegramMessage] = None"
            )
            for field in self.fields
            if (
                not field.name.endswith("_entities")
                and not field.name.endswith("parse_mode")
                and field.name not in exclude_fields
            )
        ]
        result = f"class {self.name.removeprefix('send')}(TelegramMedia):\n"
        result += indent("\n".join(fields))
        return result


class TypeDescription(BaseModel):
    """Telegram API 类型描述。"""

    name: str
    href: str
    description: Optional[list[str]] = None
    fields: list[FieldDescription] = Field(default_factory=list)
    subtypes: list[str] = Field(default_factory=list)
    subtype_of: list[str] = Field(default_factory=list)

    def to_model(self) -> str:
        """生成模型代码。"""
        if self.name == "InputFile":
            result = "InputFile = Union[bytes, tuple[str, bytes]]"
        elif not self.fields and self.subtypes:
            result = f"{self.name} = {to_annotation(self.subtypes)}"
        else:
            result = f"class {self.name}(BaseModel):\n"
            fields = [field.to_python(with_pydantic=True) for field in self.fields]
            if not fields:
                result += indent("pass")
            else:
                result += indent("\n".join(fields))
        CREATED_MODELS.add(self.name)
        return result


class APIDescription(BaseModel):
    """Telegram API 描述。"""

    version: str
    release_date: str
    changelog: str
    methods: dict[str, MethodDescription]
    types: dict[str, TypeDescription]

    def sorted_models(self) -> list[TypeDescription]:
        """返回按照依赖顺序排列的模型列表。"""
        dependencies_dict: dict[str, list[str]] = {}
        for model in self.types.values():
            dependencies_dict[model.name] = []
            for field in model.fields:
                for t_ in field.types:
                    t = t_
                    while t.startswith("Array of "):
                        t = t.removeprefix("Array of ")
                    if t not in TG_TO_PY_TYPE:
                        dependencies_dict[model.name].append(t)
            for subtype in model.subtypes:
                dependencies_dict[model.name].append(subtype)

        def sort_models(models: list[TypeDescription]) -> list[TypeDescription]:
            result: list[TypeDescription] = []
            for model in models:
                if model.name not in dependencies_dict:
                    continue
                result.extend(
                    sort_models(
                        [self.types[name] for name in dependencies_dict.pop(model.name)]
                    )
                )
                result.append(model)
            return result

        return sort_models(list(self.types.values()))

    def gen_model(self) -> str:
        """生成模型代码。"""
        USED_MODELS.clear()
        model_code = "\n\n\n".join(model.to_model() for model in self.sorted_models())
        return MODEL_CODE_PREFIX + model_code

    def gen_api(self) -> str:
        """生成 API 类的代码。"""
        USED_MODELS.clear()
        api_code = "class TelegramAPI:\n" + indent(
            "\n\n".join(method.to_api_method() for method in self.methods.values())
        )
        return API_CODE_PREFIX.format(", ".join(USED_MODELS)) + api_code

    def gen_media(self) -> str:
        """生成 TelegramMedia 模型代码。"""
        USED_MODELS.clear()
        media_code = "\n\n\n".join(
            x
            for x in (model.to_media_model() for model in self.methods.values())
            if x is not None
        )
        return MEDIA_CODE_PREFIX.format(", ".join(USED_MODELS)) + media_code


def to_annotation(t: Union[list[str], str]) -> str:
    """从 Telegram 类型转换为 Python 类型注解。"""
    if isinstance(t, list):
        if len(t) > 1:
            return f"Union[{', '.join(to_annotation(t) for t in t)}]"

        t = t[0]

    if t.startswith("Array of"):
        return f"list[{to_annotation(t.removeprefix('Array of '))}]"

    if t in TG_TO_PY_TYPE:
        return TG_TO_PY_TYPE[t]

    USED_MODELS.add(t)

    if t in CREATED_MODELS:
        return t

    return f'"{t}"'


def lower_camel_to_snake_case(lower_camel_case: str) -> str:
    """将 lowerCamelCase 转换为 snake_case。

    Args:
        lower_camel_case: lowerCamelCase 字符串。

    Returns:
        snake_case 字符串。
    """
    snake_case = ""
    for s in lower_camel_case:
        if s.isupper():
            snake_case += "_"
        snake_case += s.lower()
    return snake_case


def indent(text: str) -> str:
    """缩进。

    Args:
        text: 文本。
        level: 缩进级别，默认为 1。

    Returns:
        缩进的文本。
    """
    return "\n".join("    " + line if line else line for line in text.split("\n"))


def ruff_format(file_path: Path) -> None:
    """使用 Ruff 格式化。

    Args:
        file_path: 文件路径。
    """
    subprocess.run(f"ruff format {file_path}", check=True, shell=True)  # noqa: S602
    subprocess.run(f"ruff check --fix {file_path}", check=True, shell=True)  # noqa: S602


async def main() -> None:
    """生成 API 类和模型代码。"""
    async with aiohttp.ClientSession() as session, session.get(URL) as response:
        api = APIDescription.model_validate_json(await response.read())
    MODEL_FILE.write_text(api.gen_model())
    API_FILE.write_text(api.gen_api())
    MEDIA_FILE.write_text(api.gen_media())
    ruff_format(MODEL_FILE)
    ruff_format(API_FILE)
    ruff_format(MEDIA_FILE)


if __name__ == "__main__":
    anyio.run(main)
